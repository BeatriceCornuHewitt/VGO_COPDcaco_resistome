---
title: "Visualising the VGO resistome data"
output: html_notebook
---

```{r}
knitr::opts_knit$set(root.dir = "C:/Users/Cornu003/OneDrive - Universiteit Utrecht/Documents/PhD/Manuscripts/2. Resistome/R_scripts/VGO_COPDcaco_resistome") # set the working directory to the R project file. 
```
# Stacked bar charts
## Absolute abundances
```{r}
# Create ggplot for COPD cases
AMRclass.absolute.copd <- AMRclass.aggl
AMRclass.absolute.copd <- prune_samples(sample_data(AMRclass.absolute.copd)$copdcaco == "1", AMRclass.absolute.copd)
AMRclass.absolute.bars.copd <- plot_bar(AMRclass.absolute.copd, fill = "ARG_class") +
  labs(title = "COPD Only") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0.4, hjust = 0, size = 8)) 
ggsave("Output_files//AMR_abundance_plots//Absolute_abundances//AMRclass.absolute.bars.copd.png",width = 8, height = 4,dpi = 3000)

# Create ggplot for Controls
AMRclass.absolute.control <- AMRclass.aggl
AMRclass.absolute.control <- prune_samples(sample_data(AMRclass.absolute.control)$copdcaco == "0", AMRclass.absolute.control)
AMRclass.absolute.bars.control <- plot_bar(AMRclass.absolute.control, fill = "ARG_class") +
  labs(title = "Control Only") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0.4, hjust = 0, size = 8))
ggsave("Output_files//AMR_abundance_plots//Absolute_abundances//AMRclass.absolute.bars.control.png",width = 8, height = 4,dpi = 3000)

# Create ggplot for Blanks
AMRclass.absolute.blanks <- AMRclass.aggl
AMRclass.absolute.blanks <- prune_samples(sample_data(AMRclass.absolute.blanks)$copdcaco == "blanc", AMRclass.absolute.blanks)
AMRclass.absolute.bars.blanks <- plot_bar(AMRclass.absolute.blanks, fill = "ARG_class") +
  labs(title = "Blanks Only") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0.4, hjust = 0, size = 8))
ggsave("Output_files//AMR_abundance_plots//Absolute_abundances//AMRclass.absolute.bars.blanks.png",width = 8, height = 4,dpi = 3000)

# Combine the plots using patchwork
combined_plots_absolute <- (
  AMRclass.absolute.bars.control|
  AMRclass.absolute.bars.copd|
  AMRclass.absolute.bars.blanks
)

# Set a common y-axis label
common_y_axis_label <- "Abundance"
# Add a common title for the entire layout
COPDcontrolblank_plots_absolute <- combined_plots_absolute +
  plot_layout(ncol = 3, byrow = TRUE, guides = "collect") +
  plot_annotation(title = "Total rarefied, gene length corrected and 16S qPCR corrected resistome absolute abundance", theme = theme(plot.title = element_text(hjust = 0.5, size = 20)))
COPDcontrolblank_plots_absolute
ggsave("Output_files//AMR_abundance_plots//Absolute_abundances//COPDcontrolblank_plots_absolute.png",width = 8, height = 4,dpi = 3000)








# Combining groups into one bar 
# Create function to produce bar charts based on absolute abundance
bar.graphs.absolute <- function(physeq, var1 = "ungrouped", level, displayx = 10, filetype = ".jpg") {
  if (level == "Species") {
    print("Error this level is too fine for amplicon sequencing")
  } else if (var1 == "ungrouped") {
    physeqxu <- tax_glom(physeq, level)
    physeqxu <- prune_taxa(names(sort(taxa_sums(physeqxu), TRUE))[1:displayx], physeqxu)
    barchartxu <- plot_bar(physeqxu, fill = level) +
      labs(x = "COPD or control samples",
           y = "Absolute abundance",
           title = paste("Top", displayx, level, "ungrouped")) +
      scale_fill_brewer(palette = "Spectral")
    return(barchartxu)
  } else {
    physeqm <- merge_samples(physeq, var1)
    sample_data(physeqm)[[var1]] <- levels(sample_data(physeqm)[[var1]])
    physeqg <- tax_glom(physeqm, level)
    physeqg <- prune_taxa(names(sort(taxa_sums(physeqg), TRUE))[1:displayx], physeqg)
    grouped_bar <- plot_bar(physeqg, fill = level) +
      labs(x = "COPD, control or blank samples",
           y = "Absolute abundance",
           title = paste("Top", displayx, level, sep = " ")) +
      scale_fill_brewer(palette = "Spectral")
    return(grouped_bar)
  }
}


AMRclass.absolute.bars_groupedcopdcaco <- bar.graphs.absolute(AMRclass.aggl, "copdcaco", "ARG_class") +
  ggtitle("Total rarefied, gene length corrected and 16S qPCR corrected resistome absolute abundance") +
  labs(fill = "AMR class") +
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 15),
        axis.text.x = element_text(angle = 0, hjust = 0.5),  # Align labels to the center of tick points
        title = element_text(size = 17),
        legend.title = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.position = "right") +
  scale_x_discrete(labels = c("Control", "COPD", "Blank"))

AMRclass.absolute.bars_groupedcopdcaco
ggsave("Output_files//AMR_abundance_plots//Absolute_abundances//AMRclass.absolute.bars_groupedcopdcaco.png",width = 7, height = 5,dpi = 3000)


# New plot (no blanks, same colours as individual plots)
n_colors <- length(unique(AMRclass.absolute.bars.copd$data$ARG_class))
color_palette <- viridis(n_colors)

# Remove blanks from dataset
AMRclass.aggl.noblanks <- AMRclass.aggl
AMRclass.aggl.noblanks <- prune_samples(!sample_data(AMRclass.aggl.noblanks)$copdcaco == "blanc", AMRclass.aggl.noblanks)


# Extract the fill colours from the previous plots to match
fill_colours <- c("#f8766d", "#cd9600","#7cae00","#00be67","#00bfc4","#00a9ff","#c77cff","#ff61cc")

# Reorder so that control comes first, then COPD
AMRclass.aggl.noblanks@sam_data$copdcaco <- factor(AMRclass.aggl.noblanks@sam_data$copdcaco, levels = c("Control", "COPD"))


AMRclass.aggl.noblanks.groupedcopdcaco <- bar.graphs.absolute(AMRclass.aggl.noblanks, "copdcaco", level = "ARG_class") +
  ggtitle("Total rarefied, gene length corrected and 16S qPCR corrected resistome absolute abundance") +
  scale_fill_manual(values = fill_colours) +  # Use the extracted colors
  labs(fill = "AMR class") +
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 15),
        axis.text.x = element_text(angle = 0, hjust = 0.5),  # Align labels to the center of tick points
        title = element_text(size = 17),
        legend.title = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.position = "right")

```
# ARG cluster bar plots
```{r}

# Function from AB to calculate top 10 taxa at different levels of taxonomic identification e.g. at ARG level, ARG cluster level, AMR class level etc. 
toptaxa <- function( ps, rank="ARGCluster", top=10, samples=NA, NArm=FALSE ) {
  if( ! is.na(samples[1]) ) {
    pstemp = prune_samples( samples, ps)
  } else {
    pstemp = ps
  }
  pstemp = tax_glom2( pstemp, taxrank = rank, NArm=NArm )
  pstemp = transform_sample_counts( pstemp, function(x) 100*x/sum(x) )

  if( ntaxa(pstemp) < top ) {
    top = ntaxa(pstemp)
    warning("Number of taxa in object is less then requested top list! Reduced to ", top)
  }

  toplist = names( sort( taxa_sums(pstemp), decreasing = TRUE ) )[1:top]
  return( toplist )
}

ARGcluster.aggl.not.clusternames <- ARGcluster.aggl
ARGcluster.aggl.not.clusternames <- prune_samples(!sample_data(ARGcluster.aggl.not.clusternames)$copdcaco == "blanc", ARGcluster.aggl.not.clusternames)


# Create a new ps object which holds only the 10 most abundant ARGs (for all COPD and control samples)
top10.ARGclusters.overall<- toptaxa(ARGcluster.aggl, rank="ARGCluster", top=10, samples=NA, NArm=FALSE )
top10.ARGclusters.overall

top10.ARGclusters.overall.noblanks<- toptaxa(ARGcluster.aggl.not.clusternames, rank="ARGCluster", top=10, samples=NA, NArm=FALSE )
top10.ARGclusters.overall.noblanks

# Top 10 in copd samples 
top10.ARGclusters.COPD<- toptaxa(COPD_ps, rank="ARGCluster", top=10, samples=NA, NArm=FALSE )
top10.ARGclusters.COPD

# Top 10 in control samples 
top10.ARGclusters.control<- toptaxa(control_ps, rank="ARGCluster", top=10, samples=NA, NArm=FALSE )
top10.ARGclusters.control

# Present as actual ARG cluster names 
tt <- data.frame(tax_table(ARGcluster.aggl))
# extract the names of the ARGCluster column where the row names of tt match the taxa present in the top10.ARGclusters.noblanks, top10.ARGclusters.COPD and top10.ARGclusters.control
top10clusternames_noblanks <- tt$ARGCluster[ row.names(tt) %in% top10.ARGclusters.overall.noblanks] 
top10clusternames_copd <- tt$ARGCluster[ row.names(tt) %in% top10.ARGclusters.COPD]
top10clusternames_control <- tt$ARGCluster[ row.names(tt) %in% top10.ARGclusters.control]

# Create a new ps object which holds only the 10 most abundant ARGs (for all COPD and control samples)
desired_taxa_names <- top10.ARGclusters.overall.noblanks
taxa_to_keep <- taxa_names(ARGcluster.aggl.not.clusternames) %in% desired_taxa_names
Final.ps.top10ARGClusters <- prune_taxa(taxa_to_keep, ARGcluster.aggl.not.clusternames)
Final.ps.top10ARGClusters@otu_table

Resistome.ps.noblanks.names <- Resistome.ps.noblanks
colnames(Final.ps.top10ARGClusters@otu_table) <- top10clusternames_noblanks
rownames(Final.ps.top10ARGClusters@tax_table) <- top10clusternames_noblanks


#BARPLOT
# Make a barplot like the AMR class level one done above, so that for COPD case and control groups, I present the relative abundance of each of the top 10 ARG classes
bar.graphs2 <- function(physeq, var1 = "ungrouped", level, displayx = 10, filetype = ".jpg") {
  if (level == "Species") {
    print("Error this level is too fine for amplicon sequencing")
  } else if (var1 == "ungrouped") {
    physeqxu <- tax_glom(physeq, level)
    physeqxu <- transform_sample_counts(physeqxu, function(x) 100 * x/sum(x))
    physeqxu <- prune_taxa(names(sort(taxa_sums(physeqxu), TRUE))[1:displayx], physeqxu)
    barchartxu <- plot_bar(physeqxu, fill = level) +
      labs(x = "COPD or control samples",
           y = "% of top 10 ARG clusters present",
           title = paste("Top", displayx, level, "ungrouped")) +
      scale_fill_brewer(palette = "Spectral")
    return(barchartxu)
  } else {
    physeqm <- merge_samples(physeq, var1)
    sample_data(physeqm)[[var1]] <- levels(sample_data(physeqm)[[var1]])
    physeqg <- tax_glom(physeqm, level)
    physeqg <- transform_sample_counts(physeqg, function(x) 100 * x/sum(x))
    physeqg <- prune_taxa(names(sort(taxa_sums(physeqg), TRUE))[1:displayx], physeqg)
    grouped_bar <- plot_bar(physeqg, fill = level) +
      labs(x = "COPD or control samples",
           y = "% of top 10 ARG clusters present",
           title = paste("Top", displayx, level, sep = " ")) +
      scale_fill_brewer(palette = "Spectral")
    return(grouped_bar)
  }
}

# Create a new phyloseq object with only the top 10 ARG clusters
ARGcluster.top10 <- prune_taxa(names(sort(taxa_sums(Final.ps.top10ARGClusters), decreasing = TRUE))[1:10], Final.ps.top10ARGClusters)

fill_colours10 <- c("#cc3311", "#4a86e8", "#ff9900", "#669966", "#33bbee", "#c77cff", "#bb5566", "#003399", "#ff33cc", "#ffcc00")

# Generate the stacked barplot at the top 10 ARG cluster level
ARGcluster.top10@sam_data$copdcaco <- revalue(ARGcluster.top10@sam_data$copdcaco, c("1"="COPD", "0"= "Control"))

ARGcluster.barchart <- bar.graphs2(ARGcluster.top10, "copdcaco", "ARGCluster") +
  ggtitle("Relative Abundance of Top 10 ARG Clusters in COPD and Control Groups") +
    scale_fill_manual(values = fill_colours10) +  # Use your custom color palette
  labs(fill = "ARG Cluster") +
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 15),
        axis.text.x = element_text(angle = 0, hjust = 0.5),  # Align labels to the center of tick points
        title = element_text(size = 17),
        legend.title = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.position = "right") 
ARGcluster.barchart

ggsave("Output_files//AMR_abundance_plots//Relative_abundances//ARGcluster90.copdcaco.barchart.png",width = 7, height = 5,dpi = 3000)
```



## Relative abundances 
```{r}
AMRclass.aggl <- tax_glom(Final.ps, taxrank = rank_names(Final.ps)[1])
AMRclass.relative <- transform_sample_counts(AMRclass.aggl, function(x) x / sum(x) * 100)

# Create ggplot for COPD cases
AMRclass.relative.copd <- AMRclass.relative
AMRclass.relative.copd <- prune_samples(sample_data(AMRclass.relative.copd)$copdcaco == "1", AMRclass.relative.copd)
AMRclass.relative.bars.copd <- plot_bar(AMRclass.relative.copd, fill = "ARG_class") +
  labs(title = "COPD Only") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0.4, hjust = 0, size = 8)) 
ggsave("Output_files//AMR_abundance_plots//Relative_abundances//AMRclass.relative.bars.copd.png",width = 7, height = 5,dpi = 3000)

# Create ggplot for Controls
AMRclass.relative.control <- AMRclass.relative
AMRclass.relative.control <- prune_samples(sample_data(AMRclass.relative.control)$copdcaco == "0", AMRclass.relative.control)
AMRclass.relative.bars.control <- plot_bar(AMRclass.relative.control, fill = "ARG_class") +
  labs(title = "Control Only") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0.4, hjust = 0, size = 8))
ggsave("Output_files//AMR_abundance_plots//Relative_abundances//AMRclass.relative.bars.control.png",width = 7, height = 5,dpi = 3000)


# Create ggplot for Blanks
AMRclass.relative.blanks <- AMRclass.relative
AMRclass.relative.blanks <- prune_samples(sample_data(AMRclass.relative.blanks)$copdcaco == "blanc", AMRclass.relative.blanks)
AMRclass.relative.bars.blanks <- plot_bar(AMRclass.relative.blanks, fill = "ARG_class") +
  labs(title = "Blanks Only") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0.4, hjust = 0, size = 8))
ggsave("Output_files//AMR_abundance_plots//Relative_abundances//AMRclass.relative.bars.blanks.png",width = 7, height = 5,dpi = 3000)

# Combine the plots using patchwork
combined_plots_relative <- (
  AMRclass.relative.bars.copd |
  AMRclass.relative.bars.control |
  AMRclass.relative.bars.blanks
)

# Set a common y-axis label
common_y_axis_label <- "Abundance"

# Add a common title for the entire layout
COPDcontrolblank_plots_relative <- combined_plots_relative +
  plot_layout(ncol = 3, byrow = TRUE, guides = "collect") +
  plot_annotation(title = "Total rarefied, gene length corrected and 16S qPCR corrected resistome relative abundance", theme = theme(plot.title = element_text(hjust = 0.5, size = 20)))
COPDcontrolblank_plots_relative
ggsave("Output_files//AMR_abundance_plots//Relative_abundances//COPDcontrolblank_plots_relative.png",width = 7, height = 5,dpi = 3000)

# Combined
# Sample number vs relative AMR class (COPD, controls & blanks)
AMRclass.relative.bars <- plot_bar( AMRclass.relative, fill="ARG_class") +
    labs( title="Total rarefied, gene length corrected and 16S qPCR corrected resistome relative abundance", x="Sample", y="Abundance (%)") 

AMRclass.relative.bars + theme( axis.text.x = element_text( angle=270, vjust=0.4, hjust=0, size=8 ) )
ggsave("Output_files//AMR_abundance_plots//Relative_abundances//AMRclass.relative.bars.png",width = 7, height = 5,dpi = 3000)

# Sample number vs relative AMR class (COPD & controls)
blancs <- c("veldbl16", "veldbl3", "veldbl5")
AMRclass.relative.noblanks <- AMRclass.relative
AMRclass.relative.noblanks <-  prune_samples(!sample_names(AMRclass.relative)%in%blancs, AMRclass.relative)
AMRclass.relative.noblanks;AMRclass.relative # the 3 blanks have now been removed 

AMRclass.relative.bars.noblanks <- plot_bar(AMRclass.relative.noblanks, fill="ARG_class") +
    labs( title="Total rarefied, gene length corrected and 16S qPCR corrected resistome relative abundance", x="Sample", y="Abundance (%)") 

AMRclass.relative.bars.noblanks + theme( axis.text.x = element_text( angle=270, vjust=0.4, hjust=0, size=5 ) )
ggsave("Output_files//AMR_abundance_plots//Relative_abundances//AMRclass.relative.bars.noblanks.png",width = 7, height = 5,dpi = 3000)


# Combining groups into one bar 
# Create function to produce grouped bar charts for relative abundance
bar.graphs.relative <- function(physeq, var1 = "ungrouped", level, displayx = 10, filetype = ".jpg") {
  if (level == "Species") {
    print("Error this level is too fine for amplicon sequencing")
  } else if (var1 == "ungrouped") {
    physeqxu <- tax_glom(physeq, level)
    # physeqxu <- transform_sample_counts(physeqxu, function(x) 100 * x/sum(x)) # removed line since I've already transformed my ps object to relative counts
    physeqxu <- prune_taxa(names(sort(taxa_sums(physeqxu), TRUE))[1:displayx], physeqxu)
    barchartxu <- plot_bar(physeqxu, fill = level) +
      labs(x = "COPD, control or blank samples",
           y = "% of total AMR composition",
           title = paste("Top", displayx, level, "ungrouped")) +
      scale_fill_brewer(palette = "Spectral")
    return(barchartxu)
  } else {
    physeqm <- merge_samples(physeq, var1)
    sample_data(physeqm)[[var1]] <- levels(sample_data(physeqm)[[var1]])
    physeqg <- tax_glom(physeqm, level)
    physeqg <- transform_sample_counts(physeqg, function(x) 100 * x/sum(x))
    physeqg <- prune_taxa(names(sort(taxa_sums(physeqg), TRUE))[1:displayx], physeqg)
    grouped_bar <- plot_bar(physeqg, fill = level) +
      labs(x = "COPD, control or blank samples",
           y = "% of total AMR composition",
           title = paste("Top", displayx, level, sep = " ")) +
      scale_fill_brewer(palette = "Spectral")
    return(grouped_bar)
  }
}


# New plot (no blanks, same colours as individual plots)
n_colors <- length(unique(AMRclass.absolute.bars.copd$data$ARG_class))
color_palette <- viridis(n_colors)

# Remove blanks from dataset
AMRclass.relative.noblanks <- AMRclass.relative
AMRclass.relative.noblanks <- prune_samples(!sample_data(AMRclass.relative.noblanks)$copdcaco == "blanc", AMRclass.relative.noblanks)

# Extract the fill colours from the previous plots to match
fill_colours <- c("#f8766d", "#cd9600","#7cae00","#00be67","#00bfc4","#00a9ff","#c77cff","#ff61cc")

# Reorder so that control comes first, then COPD
AMRclass.relative.noblanks@sam_data$copdcaco <- revalue(AMRclass.relative.noblanks@sam_data$copdcaco, c('1' ='COPD', '0' = 'Control'))

AMRclass.aggl.noblanks.groupedcopdcaco <- bar.graphs.relative(AMRclass.relative, "copdcaco", level = "ARG_class") +
  ggtitle("Total rarefied, gene length corrected and 16S qPCR corrected resistome absolute abundance") +
  scale_fill_manual(values = fill_colours) +  # Use the extracted colors
  labs(fill = "AMR class") +
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 15),
        axis.text.x = element_text(angle = 0, hjust = 0.5),  # Align labels to the center of tick points
        title = element_text(size = 17),
        legend.title = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.position = "right")

print(AMRclass.relative.bars_groupedcopdcaco)
ggsave("Output_files//AMR_abundance_plots//Relative_abundances//AMRclass.relative.bars_groupedcopdcaco.png",width = 7, height = 5,dpi = 3000)



# Grouped stacked bar chart (COPD, controls & blanks)
AMRcAMRclass.aggl.noblanks.groupedcopdcaco <- bar.graphs.relative(AMRclass.relative.noblanks, "copdcaco", level = "ARG_class") +
  ggtitle("Total rarefied, gene length corrected and 16S qPCR corrected resistome absolute abundance") +
  scale_fill_manual(values = fill_colours) +  # Use the extracted colors
  labs(fill = "AMR class") +
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 15),
        axis.text.x = element_text(angle = 0, hjust = 0.5),  # Align labels to the center of tick points
        title = element_text(size = 17),
        legend.title = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.position = "right")

print(AMRclass.relative.bars_groupedcopdcaco)
ggsave("Output_files//AMR_abundance_plots//Relative_abundances//AMRclass.relative.bars_groupedcopdcaco.noblanks.png",width = 7, height = 5,dpi = 3000)
```
# Heatmaps
## ARG level (not clustered)
```{r}
# Extract abundance matrix from phyloseq object - Final.ps is the ps object which is not clustered at the 90% identity level
ARGs <- as(otu_table(Final.ps), "matrix")
# transform into a data frame
ARG.dataframe <-as.data.frame(ARGs)

# Transform the raw counts of reads to proportions of total ARGs in each sample 
ARG.dataframe.prop <- ARG.dataframe/rowSums(ARG.dataframe)
ARG.dataframe.prop

# Calculate the Bray-Curtis dissimilarity matrix on the full dataset
ARG.BCdist <- vegdist(ARG.dataframe.prop, method = "bray")
# Perform hierarchical cluster analysis using the BC dissimilarities 
# Each sample is assigned to its own cluster and then the algorithm proceeds iteratively, at each stage joining the two most similar clusters, continuing until there is just a single cluster.
sample.clust <- hclust(ARG.BCdist, "aver")
# make the heatmap with clustering of the samples (rows) (Rowv = as.dendrogram(sample.clust))
# Note that the samples are not in the same order as that in the matrix - heatmap() reorders both variables and observations using the BC clustering algorithm: it computes the distance between each pair of rows and columns and try to order them by similarity.
heatmap_ARGlevel_clustered <- heatmap(as.matrix(ARG.dataframe.prop), Rowv = as.dendrogram(sample.clust), Colv = NA, margins = c(10, 3))
plot(heatmap_ARGlevel_clustered)

# Add additional dendogram (on the columns) to heatmap 
# Calculate the Bray-Curtis dissimilarity matrix on ARGs in the dataset
ARG.BCdist.t <- vegdist(t(ARG.dataframe.prop), method = "bray") # We transpose the data frame so samples are now in columns
# Perform hierarchical cluster analysis using the BC dissimilarities between the ARGs (columns in dataset)
col.clust <- hclust(ARG.BCdist.t, "aver")

# create the heatmap with row and column dendograms
heatmap_ARGlevel_clustered_rowcolumn <- heatmap(as.matrix(ARG.dataframe.prop), Rowv = as.dendrogram(sample.clust), Colv = as.dendrogram(col.clust), margins = c(11, 5), xlab = "ARGs", ylab = "SampleIDs", main = "Hierarchical clustering heatmap")

# Add colour code to rows to visualise whether COPD/controls/blanks cluster together (35 cases and 34 controls, 3 blanks)
# Use 'RowSideColours' argument in the heatmap() code to do this
metadata.final.ps <- sample_data(Final.ps)
COPDcontrolblank <- metadata.final.ps$copdcaco 
COPDcontrolblank<- replace(COPDcontrolblank, which(COPDcontrolblank == "0"), "blue")
COPDcontrolblank<-replace(COPDcontrolblank, which(COPDcontrolblank == "1"), "red")
COPDcontrolblank<-replace(COPDcontrolblank, which(COPDcontrolblank == "blanc"),"green")
COPDcontrolblank # check that colours are allocated to the groups

# Add these colour codes to the heatmap 
heatmap_ARGlevel_clustered_colour1 <- heatmap(as.matrix(ARG.dataframe.prop), Rowv = as.dendrogram(sample.clust), Colv = as.dendrogram(col.clust), RowSideColors = COPDcontrolblank, margins = c(11, 5), xlab = "ARGs", ylab = "SampleIDs", main = "Hierarchical clustering heatmap")
```
## ARG cluster level 
```{r}
# Create a heatmap now on the cluster 90 level as this is a better representation of the data 
# Extract abundance matrix from cluster 90 agglomerated ps object
ARGclustertable <- as(otu_table(ARGcluster.aggl), "matrix")
# transform into a data frame
ARGcluster.dataframe <- as.data.frame(ARGclustertable)
ARGcluster.dataframe
# Examine actual cluster 90 names and names assigned in the ps object
ARGcluster.aggl@tax_table[,6]

# column names are (specific) ARG names, agglomeration is correct (lowest level is ARG cluster) but col names are not correct - I will rename the column names to the AMR classes for presentation in the heatmap
colnames(ARGcluster.dataframe) <- c("aac(3)-II_clust","aac(3)-Iva","aac(6')-aph(2'')_clust","aadA_ant(3'')-Ia_clust","aadA_clust1","aadD","ant(6)-Ia_clust2","aph(3'')-Ib","aph(3')-Ia_aph(3')-Ic","aph(3')-Ib","aph(3')-III","aph(4)-Ia","aph(6)-Id","str","blaACT_clust","blaACT_CMG_MIR_clust","blaBRO","blaCARB_clust2","blaCTX-M_clust1","blaOXA-22","blaOXA-395_clust","blaOXA-60_clust","blaOXA-85","blaOXA_clust19","blaOXA_clust3","blaOXA_clust8","blaOXA_clust9","blaOXY_clust1","blaSPU-1","blaTEM_clust","blaZ_clust","cfxA_clust","mecA_clust","mecA1","penA","fusB","lsa(A)","lsa(C)","erm(A)_2_AF002716","erm(B)_clust","erm(C)_clust","erm(F)_clust","erm(T)_4_AJ488494","erm(X)_clust","lnu(C)","mdf(A)","mef(A)-3","mef(A)_clust","mph(A)","mph(C)","msr(A)","msr(D)","msr(E)","vga(A)_clust","cat(pC194)","cat_2","catA1","catQ","catS","cml_clust","cmx","cfr(C)","sul1","sul2","tet(32)","tet(33)","tet(37)","tet(39)","tet(40)","tet(44)","tet(A)","tet(B)","tet(C)","tet(G)","tet(K)","tet(L)_clust1","tet(M)","tet(O)","tet(O/32/O)","tet(O/W/32/O/W/O)","tet(O/W/O)-1","tet(Q)","tet(T)","tet(W)","dfrA15_clust")

# Check the renaming has been performed correctly
colnames(ARGcluster.dataframe)

# transform the raw counts of reads to proportions of total ARG clusters in each sample 
ARGcluster.dataframe.prop <- ARGcluster.dataframe/rowSums(ARGcluster.dataframe)
# Examine the dataframe 
ARGcluster.dataframe.prop

# calculate the Bray-Curtis dissimilarity matrix on the full dataset
ARGCluster.BCdist <- vegdist(ARGcluster.dataframe.prop, method = "bray")

# perform hierarchical cluster analysis using the BC dissimilarities 
# each sample is assigned to its own cluster and then the algorithm proceeds iteratively, at each stage joining the two most similar clusters, continuing until there is just a single cluster.
ARGCluster.clust <- hclust(ARGCluster.BCdist, "aver")

# Create a heatmap at the ARG cluster level
heatmap.ARGClusterlevel <- heatmap(as.matrix(ARGcluster.dataframe.prop), Rowv = as.dendrogram(ARGCluster.clust), RowSideColors = COPDcontrolblank, margins = c(11, 5), xlab = "ARGCluster", ylab = "SampleIDs", main = "Hierarchical clustering heatmap at 90% ARG cluster level")
# Note that the samples are not in the same order as that in the matrix - heatmap() reorders both variables and observations using the BC clustering algorithm: it computes the distance between each pair of rows and columns and try to order them by similarity.


# Using tutorial: https://slowkow.com/notes/pheatmap-tutorial/
# Use the data frame which I created previously for ARG cluster level 
ARGcluster.dataframe.prop
# convert ARG Cluster df to matrix form - this is needed for pheatmap function
ARGcluster.prop.mat <- as.matrix(ARGcluster.dataframe.prop)
# check the matrix to see it is formulated correctly
rownames(ARGcluster.prop.mat)
colnames(ARGcluster.prop.mat)

# create a new df with column for copdcaco status - in order to label the heatmap by sample type (colour coding later on)
ARG.cluster.df.copdcaco <- ARGcluster.dataframe.prop
ARG.cluster.df.copdcaco$copdcaco <- Final.ps@sam_data$copdcaco
copdcaco_df<- data.frame("COPD/control/blank" = ARG.cluster.df.copdcaco$copdcaco)
rownames(copdcaco_df) = rownames(ARG.cluster.df.copdcaco) # name matching
# specify the colours wanted as the key (annotation_colours argument in pheatmap function) - red-COPD, blue-control, green-blank
row.colors = list(COPD.control.blank = c("1" = "#FF0000", "0" = "#0000FF", "blanc"= "#00FF00" ))

# Specify BC clustering for pheatmap 
BCdist.rows <- vegdist(ARGcluster.dataframe.prop, method="bray", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = FALSE)
BCdist.cols <- vegdist(t(ARGcluster.dataframe.prop), method="bray", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = FALSE)
pheatmap(ARGcluster.prop.mat, cluster_rows=FALSE, cluster_cols=FALSE)

# Create heatmap including all ARG clusters. BC distance clustering, colour coding for COPD/control/blank samples on y-axis
ARG_cluster_heatmap <- pheatmap(
  mat = ARGcluster.prop.mat,
  color = colorRampPalette(rev(brewer.pal(n = 10, name = "RdYlBu")))(100), # see other colour palettes: https://www.datanovia.com/en/blog/the-a-z-of-rcolorbrewer-palette/ (also can change from (10) to another number to change density of colour)
  border_color = "grey60",
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  clustering_distance_rows = BCdist.rows, # using the BC values calculated previously 
  clustering_distance_cols = BCdist.cols ,
  show_colnames = TRUE,
  show_rownames = TRUE,
  annotation_row = copdcaco_df, # annotates COPD/control/blanks and colour codes them - I want to change the colours though to red COPD, blue control, green blank
  annotation_colors = row.colors, # change colours to red COPD, blue control, green blank (see annotat) 
  drop_levels = TRUE,
  fontsize= 15,
  fontsize_row = 10,
  fontsize_col= 10,
  main= "Heatmap at ARG cluster level")

ggsave("Output_files//Heatmaps//heatmap.png", width = 10, height = 8)  # Adjust width and height as needed
ggsave("Output_files//Heatmaps//ARG_cluster_heatmap.png", ARG_cluster_heatmap, width = 10, height = 8)
# Save the heatmap as a PNG file
png("Output_files//Heatmaps//ARG_cluster_heatmap.png", width = 10, height = 8, units = "in", res = 300)
print(ARG_cluster_heatmap)
dev.off() # Close the PNG device
getwd()
```


#### Heatmap at AMR class level 
##### Standard R heatmap at AMR class level 
```{r}
# Create a heatmap on the AMR class level? Is this normal to do or not appropriate/needed? Maybe I lose too much resolution by doing this...
#Extract abundance matrix from phyloseq object
AMRclasstable <- as(otu_table(AMRclass.aggl), "matrix")
# transform into a data frame
AMRclass.dataframe <-as.data.frame(AMRclasstable)
AMRclass.dataframe

# column names are (specific) ARG names, agglomeration is correct (lowest level is AMR class) but col names are not correct - I will rename the column names to the AMR classes for presentation in the heatmap
colnames(AMRclass.dataframe) <- c("Aminoglycoside", "Beta-Lactam", "Macrolide", "Tetracycline", "Phenicol", "Sulphonamide", "Trimethoprim", "Fusidicacid")

# Check the renaming has been performed correctly
AMRclass.dataframe
view(AMRclass.dataframe)

# transform the raw counts of reads to proportions of total AMR class in each sample 
AMRclass.dataframe.prop <- AMRclass.dataframe/rowSums(AMRclass.dataframe)
# examine the dataframe 
AMRclass.dataframe.prop
AMRclass.dataframe.prop[1:3, 1:3]

# calculate the Bray-Curtis dissimilarity matrix on the full dataset
AMRclass.BCdist <- vegdist(AMRclass.dataframe.prop, method = "bray")

# perform hierarchical cluster analysis using the BC dissimilarities 
# each sample is assigned to its own cluster and then the algorithm proceeds iteratively, at each stage joining the two most similar clusters, continuing until there is just a single cluster.
sample.clust2 <- hclust(AMRclass.BCdist, "aver")

# perform hierarchical cluster analysis using the BC dissimilarities between the AMR classes (columns in dataset)
AMRclass.clust <- hclust(AMRclass.BCdist, "aver")

# Create a heatmap at the AMR class level
heatmap.AMRclasslevel <- heatmap(as.matrix(AMRclass.dataframe.prop), Rowv = as.dendrogram(sample.clust2), RowSideColors = COPDcontrolblank, margins = c(11, 5), xlab = "AMR class", ylab = "SampleIDs", main = "Hierarchical clustering heatmap at AMR class level")

# Note that the samples are not in the same order as that in the matrix - heatmap() reorders both variables and observations using the BC clustering algorithm: it computes the distance between each pair of rows and columns and try to order them by similarity.
```

##### Pheatmap at AMR class level
```{r}
# Heatmap at AMR class level (using pheatmap)
AMRclass.dataframe.prop # use previous df created

# convert AMR Class df to matrix form - this is needed for pheatmap function
AMRclass.prop.mat <- as.matrix(AMRclass.dataframe.prop)

# check the matrix to see it is formulated correctly
rownames(AMRclass.prop.mat)
colnames(AMRclass.prop.mat)

# create a new df with column for copdcaco status - in order to label the heatmap by sample type (colour coding later on)
AMRclass.dataframe.prop.copdcaco <- AMRclass.dataframe.prop
AMRclass.dataframe.prop.copdcaco$copdcaco <- Final.ps@sam_data$copdcaco
AMRclass.copdcaco.df<- data.frame("COPD/control/blank" = AMRclass.dataframe.prop.copdcaco$copdcaco)
rownames(AMRclass.copdcaco.df) = rownames(AMRclass.dataframe.prop.copdcaco) # name matching
# specify the colours wanted as the key (annotation_colours argument in pheatmap function) - red-COPD, blue-control, green-blank
row.colors.AMRclass = list( COPD.control.blank = c("1" = "#FF0000", "0" = "#0000FF", "blanc"= "#00FF00" ))

# Specify BC clustering for pheatmap - default is euclidean(?)
AMRclass.BCdist.rows <- vegdist(AMRclass.dataframe.prop, method="bray", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = FALSE)
AMRclass.BCdist.cols <- vegdist(t(AMRclass.dataframe.prop), method="bray", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = FALSE)

# Create heatmap including all ARG clusters. BC distance clustering, colour coding for COPD/control/blank samples on y-axis

pheatmap(
  mat = AMRclass.prop.mat,
  color = colorRampPalette(rev(brewer.pal(n = 10, name = "RdYlBu")))(100), # see other colour palettes: https://www.datanovia.com/en/blog/the-a-z-of-rcolorbrewer-palette/ (also can change from (10) to another number to change density of colour)
  border_color = "grey60",
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  clustering_distance_rows = AMRclass.BCdist.rows, # using the BC values calculated previously 
  clustering_distance_cols = AMRclass.BCdist.cols ,
  show_colnames = TRUE,
  show_rownames = TRUE,
  annotation_row = AMRclass.copdcaco.df, # annotates COPD/control/blanks and colour codes them - I want to change the colours though to red COPD, blue control, green blank
  annotation_colors = row.colors.AMRclass, # change colours to red COPD, blue control, green blank (see annotat) 
  drop_levels = TRUE,
  fontsize= 20,
  fontsize_row = 10,
  fontsize_col= 20,
  main= "Heatmap at AMR class level"
)
```